import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

function formatPrice(rupees: number): string {
  return new Intl.NumberFormat('en-IN', {
    style: 'currency',
    currency: 'INR',
    maximumFractionDigits: 0,
  }).format(rupees);
}

// GET all orders with stats
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { searchParams } = new URL(request.url);
    
    const search = searchParams.get("search");
    const status = searchParams.get("status");
    const limit = parseInt(searchParams.get("limit") || "50");
    const offset = parseInt(searchParams.get("offset") || "0");

    let query = supabase
      .from("orders")
      .select("*", { count: "exact" })
      .order("created_at", { ascending: false })
      .range(offset, offset + limit - 1);

    if (search) {
      query = query.or(`order_number.ilike.%${search}%,customer_name.ilike.%${search}%,phone_name.ilike.%${search}%`);
    }
    
    if (status && status !== "all") {
      query = query.eq("status", status);
    }

    const { data: orders, error, count } = await query;

    if (error) {
      console.error("Error fetching orders:", error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Calculate stats
    const allOrders = await supabase.from("orders").select("status, final_amount");
    const ordersData = allOrders.data || [];
    
    const completedOrders = ordersData.filter(o => o.status === "completed" || o.status === "delivered");
    const totalRevenue = completedOrders.reduce((acc, o) => acc + (o.final_amount || 0), 0);

    const stats = {
      total: ordersData.length,
      pending: ordersData.filter(o => o.status === "pending").length,
      processing: ordersData.filter(o => o.status === "processing" || o.status === "confirmed").length,
      shipped: ordersData.filter(o => o.status === "shipped").length,
      completed: completedOrders.length,
      cancelled: ordersData.filter(o => o.status === "cancelled").length,
      revenue: totalRevenue,
      revenueFormatted: formatPrice(totalRevenue),
    };

    return NextResponse.json({ 
      orders: orders?.map(o => ({
        ...o,
        amount: o.amount,
        discount: o.discount,
        final_amount: o.final_amount,
        amount_formatted: formatPrice(o.final_amount),
      })),
      count,
      stats
    });
  } catch (error) {
    console.error("Error in GET /api/orders:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

// POST - Create new order
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const body = await request.json();

    const {
      customer_id,
      customer_name,
      customer_phone,
      customer_email,
      phone_id,
      phone_name,
      phone_brand,
      phone_variant,
      phone_imei,
      amount,
      discount,
      payment_method,
      shipping_address,
      shipping_city,
      shipping_pincode,
      notes,
      sale_channel,
      status: inputStatus,
      payment_status: inputPaymentStatus,
      custom_data,
    } = body;

    if (!customer_name || !customer_phone || !phone_name || !amount) {
      return NextResponse.json(
        { error: "Customer name, phone, phone name, and amount are required" },
        { status: 400 }
      );
    }

    const amountValue = parseFloat(amount);
    const discountValue = discount ? parseFloat(discount) : 0;
    const finalAmount = body.final_amount || (amountValue - discountValue);

    const orderData = {
      order_number: "", // Will be generated by trigger
      customer_id: customer_id || null,
      customer_name,
      customer_phone,
      customer_email: customer_email || null,
      phone_id: phone_id || null,
      phone_name,
      phone_brand: phone_brand || null,
      phone_variant: phone_variant || null,
      phone_imei: phone_imei || null,
      amount: amountValue,
      selling_price: amountValue, // Required by DB constraint
      discount: discountValue,
      final_amount: finalAmount,
      payment_method: payment_method || null,
      shipping_address: shipping_address || null,
      shipping_city: shipping_city || "Delhi",
      shipping_pincode: shipping_pincode || null,
      notes: notes || null,
      sale_channel: sale_channel || "Store",
      status: inputStatus || "pending",
      payment_status: inputPaymentStatus || "pending",
      custom_data: custom_data || {},
    };

    const { data, error } = await supabase
      .from("orders")
      .insert([orderData])
      .select()
      .single();

    if (error) {
      console.error("Error creating order:", error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Update phone status based on order status
    if (phone_id) {
      const phoneStatus = (inputStatus === "confirmed" || inputStatus === "completed") 
        ? "Sold" 
        : "Reserved";
      
      await supabase
        .from("phones")
        .update({ 
          status: phoneStatus,
          sold_via: sale_channel || "Store"
        })
        .eq("id", phone_id);
    }

    // Create customer if doesn't exist
    if (!customer_id && customer_phone) {
      const normalizedPhone = customer_phone.replace(/[^0-9]/g, "").slice(-10);
      const { data: existingCustomer } = await supabase
        .from("customers")
        .select("id")
        .eq("phone", normalizedPhone)
        .single();
      
      if (!existingCustomer) {
        await supabase
          .from("customers")
          .insert([{
            name: customer_name,
            phone: normalizedPhone,
            email: customer_email || null,
            status: "active",
            notes: `Auto-created from order ${data.order_number}`
          }]);
      }
    }

    return NextResponse.json({ 
      order: {
        ...data,
        amount: data.amount,
        final_amount: data.final_amount,
      }, 
      message: "Order created successfully" 
    }, { status: 201 });
  } catch (error) {
    console.error("Error in POST /api/orders:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
